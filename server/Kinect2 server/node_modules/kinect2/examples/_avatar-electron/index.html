<!DOCTYPE html>
<html>
	<head>
		<title>Hello World!</title>
		<style>
		body {
			background-color: white;
		}
		</style>
	</head>
	<body>
		<canvas id="outputCanvas"></canvas>
		<script src="../shared/js/fps.js"></script>
		<script src="js/three.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script>
		(function(){
			var Kinect2 = require('../../lib/kinect2');
			var kinect = new Kinect2();

			var renderer, camera, scene, controls, loader;

			renderer = new THREE.WebGLRenderer( {
				canvas: document.getElementById('outputCanvas'),
				alpha: 1, antialias: true, clearColor: 0xffffff
			} );

			camera = new THREE.PerspectiveCamera( 40, renderer.domElement.width / renderer.domElement.height, 1, 10000 );
			camera.position.set( 0, 300, 1000 );
			controls = new THREE.TrackballControls( camera, renderer.domElement );

			scene = new THREE.Scene();

			function createGrid() {
				// ground box
				var geometry = new THREE.BoxGeometry( 500, 2, 500 );
				material = new THREE.MeshNormalMaterial();
				var mesh = new THREE.Mesh( geometry, material );
				mesh.position.set( 0, -1, 0 );
				scene.add( mesh );
				mesh = new THREE.GridHelper( 250, 10 );
				scene.add( mesh );

	      // axes
				var axis = new THREE.AxisHelper( 250 );
				scene.add( axis );
				renderer.render( scene, camera );

				var geometry = new THREE.BoxGeometry( 50, 20, 50 );
				var material = new THREE.MeshNormalMaterial();
				var box = new THREE.Mesh( geometry, material );
				scene.add( box );
      }

      //createGrid();

      function generateTexture( color ) {

				var canvas = document.createElement( 'canvas' );
				canvas.width = 32;
				canvas.height = 32;

				var context = canvas.getContext( '2d' );

				context.fillStyle = color || "#ffffff";
				context.fillRect(0,0,32,32);

				return canvas;

			}

			//load character
			var characterLoaded = false;
			var characterMesh;
			var _kinectUser;
			var _skeleton;
			var _jointMapping;
			var _currentSkeletonPose;
			var _kinectSkeletonPose;

			var _globalWisdom;
			var _localPoses;
			var _bindPoses;
			var _bindPoseOrientationsOfTrackedJoints;
			var _bindShoulderOrientation;
			var _bindSpineOrientation;
			var _trackingCenter = new THREE.Vector3();

			var _rootLocalPose;

			loader = new THREE.JSONLoader();

			function getJointIndexByName(boneName) {
				for(var i = _skeleton.bones.length - 1; i > -1; i--) {
					if(_skeleton.bones[i].name === boneName) {
						return i;
					}
				}
				return -1;
			}

			function mapJoints() {
				_jointMapping = {};
				_jointMapping[Kinect2.JointType.head] = getJointIndexByName("Head");
        _jointMapping[Kinect2.JointType.neck] = getJointIndexByName("Neck");
        _jointMapping[Kinect2.JointType.spineBase] = getJointIndexByName("Hips");

        _jointMapping[Kinect2.JointType.shoulderLeft] = getJointIndexByName("RightArm");
        _jointMapping[Kinect2.JointType.elbowLeft] = getJointIndexByName("RightForeArm");
        _jointMapping[Kinect2.JointType.handLeft] = getJointIndexByName("RightHand");

        _jointMapping[Kinect2.JointType.shoulderRight] = getJointIndexByName("LeftArm");
        _jointMapping[Kinect2.JointType.elbowRight] = getJointIndexByName("LeftForeArm");
        _jointMapping[Kinect2.JointType.handRight] = getJointIndexByName("LeftHand");

        _jointMapping[Kinect2.JointType.hipLeft] = getJointIndexByName("RightUpLeg");
        _jointMapping[Kinect2.JointType.kneeLeft] = getJointIndexByName("RightLeg");
        _jointMapping[Kinect2.JointType.footLeft] = getJointIndexByName("RightFoot");

        _jointMapping[Kinect2.JointType.hipRight] = getJointIndexByName("LeftUpLeg");
        _jointMapping[Kinect2.JointType.kneeRight] = getJointIndexByName("LeftLeg");
        _jointMapping[Kinect2.JointType.footRight] = getJointIndexByName("LeftFoot");
			}

			function initSkeleton() {
				var q1 = new THREE.Quaternion();
				var q2 = new THREE.Quaternion();
				var bind = new THREE.Matrix4();
				var parentBind = new THREE.Matrix4();

				_localPoses = new Array(_skeleton.bones.length);
				_globalWisdom = new Array(_skeleton.bones.length);
				_bindPoses = new Array(_skeleton.bones.length);

				_kinectSkeletonPose = {};
				_kinectSkeletonPose.jointPoses = new Array(_skeleton.bones.length);

				_currentSkeletonPose = {};
				_currentSkeletonPose.jointPoses = new Array(_skeleton.bones.length);

				for (var i = 0; i < _skeleton.bones.length; ++i) {
					var joint = _skeleton.bones[i];
					_localPoses[i] = {};

					_kinectSkeletonPose.jointPoses[i] = {};
					_kinectSkeletonPose.jointPoses[i].orientation = new THREE.Quaternion();
					_kinectSkeletonPose.jointPoses[i].translation = new THREE.Vector3();

					_currentSkeletonPose.jointPoses[i] = {};
					_currentSkeletonPose.jointPoses[i].orientation = new THREE.Quaternion();
					_currentSkeletonPose.jointPoses[i].translation = new THREE.Vector3();

					//bind = new Matrix3D(joint.inverseBindPose);
					//bind.invert();
					bind = _skeleton.boneInverses[i].clone();
					_bindPoses[i] = bind;

					_localPoses[i].orientation = new THREE.Quaternion();
					_localPoses[i].translation = new THREE.Vector3();
					var parentIndex = _skeleton.bones.indexOf(joint.parent);
					if (parentIndex < 0) {
						_rootLocalPose = _localPoses[i];
						_localPoses[i].orientation.setFromRotationMatrix(bind);
						var bindPosition = new THREE.Vector3();
						bindPosition.setFromMatrixPosition(bind);
						_localPoses[i].translation = bindPosition;
					}
					else {
						parentBind.copy(_skeleton.boneInverses[parentIndex]);

						q1.setFromRotationMatrix(parentBind);
						q1.normalize();
						q2.setFromRotationMatrix(bind);
						q2.normalize();
						_localPoses[i].orientation.multiplyQuaternions(q1, q2);
						var bindPosition = new THREE.Vector3();
						bindPosition.setFromMatrixPosition(bind);
						bindPosition.applyMatrix4(parentBind);
						_localPoses[i].translation = bindPosition;
					}
				}
			}

			function initBindPoseOrientations() {
				_bindPoseOrientationsOfTrackedJoints = {};

				_bindShoulderOrientation = new THREE.Vector3();
				_bindSpineOrientation = new THREE.Vector3();

				getSimpleBindOrientation(Kinect2.JointType.shoulderRight, Kinect2.JointType.shoulderLeft, _bindShoulderOrientation);
				getSimpleBindOrientation(Kinect2.JointType.spineBase, Kinect2.JointType.neck, _bindSpineOrientation);

				getSimpleBindOrientation(Kinect2.JointType.neck, Kinect2.JointType.head);
				getSimpleBindOrientation(Kinect2.JointType.shoulderLeft, Kinect2.JointType.elbowLeft);
				getSimpleBindOrientation(Kinect2.JointType.elbowLeft, Kinect2.JointType.handLeft);
				getSimpleBindOrientation(Kinect2.JointType.shoulderRight, Kinect2.JointType.elbowRight);
				getSimpleBindOrientation(Kinect2.JointType.elbowRight, Kinect2.JointType.handRight);
				getSimpleBindOrientation(Kinect2.JointType.hipLeft, Kinect2.JointType.kneeLeft);
				getSimpleBindOrientation(Kinect2.JointType.kneeLeft, Kinect2.JointType.footLeft);
				getSimpleBindOrientation(Kinect2.JointType.hipRight, Kinect2.JointType.kneeRight);
				getSimpleBindOrientation(Kinect2.JointType.kneeRight, Kinect2.JointType.footRight);
			}

			function getSimpleBindOrientation(sourceKinectJointIndex, targetKinectJointInex, storeVec) {
				var pos1;
				var pos2;
				var mapIndex1 = _jointMapping[sourceKinectJointIndex];
				var mapIndex2 = _jointMapping[targetKinectJointInex];
				if (mapIndex1 < 0 || mapIndex2 < 0) return;

				var mtx = new THREE.Matrix4();

				var pos1 = new THREE.Vector3();
				pos1.setFromMatrixPosition(_bindPoses[mapIndex1]);
				var pos2 = new THREE.Vector3();
				pos2.setFromMatrixPosition(_bindPoses[mapIndex2]);

				if (!storeVec)
					_bindPoseOrientationsOfTrackedJoints[sourceKinectJointIndex] = pos2.sub(pos1).normalize();
				else {
					storeVec.x = pos2.x - pos1.x;
					storeVec.y = pos2.y - pos1.y;
					storeVec.z = pos2.z - pos1.z;
					storeVec.normalize();
				}
			}

			function updatePose() {
				updateCentralPosition();
				updateTorso();
				updateSimpleJoint(Kinect2.JointType.neck, Kinect2.JointType.head);
				updateSimpleJoint(Kinect2.JointType.shoulderLeft, Kinect2.JointType.elbowLeft);
				updateSimpleJoint(Kinect2.JointType.elbowLeft, Kinect2.JointType.handLeft);
				updateSimpleJoint(Kinect2.JointType.shoulderRight, Kinect2.JointType.elbowRight);
				updateSimpleJoint(Kinect2.JointType.elbowRight, Kinect2.JointType.handRight);
				updateSimpleJoint(Kinect2.JointType.hipLeft, Kinect2.JointType.kneeLeft);
				updateSimpleJoint(Kinect2.JointType.kneeLeft, Kinect2.JointType.footLeft);
				updateSimpleJoint(Kinect2.JointType.hipRight, Kinect2.JointType.kneeRight);
				updateSimpleJoint(Kinect2.JointType.kneeRight, Kinect2.JointType.footRight);

				//for each(var jointName:String in _kinectUser.skeletonJointNames) {
				//	var mapIndex:int = _jointMapping[jointName];
				//	if (mapIndex >= 0 && _kinectUser.getJointByName(jointName).positionConfidence < .5)
				//	_globalWisdom[mapIndex] = false;
				//}

				/*
				var mtx = new THREE.Matrix4();
				var mtx2 = new THREE.Matrix4();

				var globalPoses = _kinectSkeletonPose.jointPoses;
				var globalJointPose;

				var joints = _skeleton.bones;
				var len = globalPoses.length;
				var parentIndex;
				var joint;

				for (var i = 0; i < len; ++i) {
					joint = joints[i];
					parentIndex = joints.indexOf(joint.parent);
					globalJointPose = globalPoses[i];
					var localPose = _localPoses[i];

					if (parentIndex < 0) {
						globalJointPose.orientation.copy(localPose.orientation);
						globalJointPose.translation.copy(localPose.translation);
					} else {
						var globalOrientation = globalJointPose.orientation;
						var globalTranslation = globalJointPose.translation;
						var localOrientation = localPose.orientation;
						var localTranslation = localPose.translation;

						var parentPose = _kinectSkeletonPose.jointPoses[parentIndex];
						var parentOrientation = parentPose.orientation;
						var parentTranslation = parentPose.translation;

						//rotatePoint(vector:Vector3D, target:Vector3D = null):Vector3D
						//parentPose.orientation.rotatePoint(localTranslation, globalTranslation);

						//parentPose.orientation.multiplyVector3(localTranslation, globalTranslation);

						globalTranslation.copy(localTranslation);
						globalTranslation.applyQuaternion(parentPose.orientation);

						globalTranslation.x += parentTranslation.x;
						globalTranslation.y += parentTranslation.y;
						globalTranslation.z += parentTranslation.z;
						if (!_globalWisdom[i]) {
							globalOrientation.multiplyQuaternions(parentOrientation, localOrientation);
							globalOrientation.normalize();
						}
						else {
							//mtx.compose(_bindPoses[i].translation, _bindPoses[i].orientation, new THREE.Vector3(1, 1, 1));
							mtx.copy(_bindPoses[i]);
							mtx2.makeRotationFromQuaternion(globalOrientation);
							//mtx.append(globalOrientation.toMatrix3D(mtx2));
							mtx.multiply(mtx2);
							globalOrientation.setFromRotationMatrix(mtx);
						}
					}
					//update the bone
					_skeleton.bones[i].quaternion.copy(globalJointPose.orientation);
					_skeleton.bones[i].position.copy(globalJointPose.translation);
					//_currentSkeletonPose.jointPoses[i].copyFrom(globalJointPose);
				}
				*/

				//var mapIndex = _jointMapping[Kinect2.JointType.spineBase];
				//_skeleton.bones[mapIndex].position.copy(_rootLocalPose.translation);

				//shoulderleft bone
				var mapIndex = _jointMapping[Kinect2.JointType.shoulderLeft];
				_skeleton.bones[mapIndex].quaternion.copy(_kinectSkeletonPose.jointPoses[mapIndex].orientation);

			}

			function getPosition(kinectSkeletonJoint) {
				return new THREE.Vector3(kinectSkeletonJoint.cameraX, kinectSkeletonJoint.cameraY, kinectSkeletonJoint.cameraZ);
			}

			function updateCentralPosition() {
				var center = getPosition(_kinectUser.joints[Kinect2.JointType.spineBase]);
				var tr = _rootLocalPose.translation;
				var _posSmoothing = .8;
				var invPosSmoothing = 1 - _posSmoothing;

				var _trackScale = .1;
				tr.x = tr.x + ((center.x - _trackingCenter.x) * _trackScale - tr.x) * invPosSmoothing;
				tr.y = tr.y + ((center.y - _trackingCenter.y) * _trackScale - tr.y) * invPosSmoothing;
				tr.z = tr.z + ((center.z - _trackingCenter.z) * _trackScale - tr.z) * invPosSmoothing;

				console.log(tr.x, tr.y, tr.z);
			}

			function updateTorso() {
				var mapIndex = _jointMapping[Kinect2.JointType.spineBase];
				if (mapIndex < 0) return;

				_globalWisdom[mapIndex] = true;

				var shoulderDir = getPosition(_kinectUser.joints[Kinect2.JointType.shoulderLeft]).sub(getPosition(_kinectUser.joints[Kinect2.JointType.shoulderRight]));
				shoulderDir.y = 0.0;
				shoulderDir.normalize();
				var axis = _bindShoulderOrientation.cross(shoulderDir);
				var torsoYawRotation = new THREE.Quaternion();
				torsoYawRotation.setFromAxisAngle(axis, Math.acos(_bindShoulderOrientation.dot(shoulderDir)));

				var pos1 = getPosition(_kinectUser.joints[Kinect2.JointType.neck]);
				var pos2 = getPosition(_kinectUser.joints[Kinect2.JointType.spineBase]);
				var spineDir = new THREE.Vector3();
				spineDir.x = 0.0;
				spineDir.y = pos1.y - pos2.y;
				spineDir.z = pos1.z - pos2.z;
				spineDir.normalize();
				axis = _bindSpineOrientation.cross(spineDir);
				var torsoPitchRotation = new THREE.Quaternion();
				torsoPitchRotation.setFromAxisAngle(axis, Math.acos(_bindSpineOrientation.dot(spineDir)));

				spineDir.x = pos1.x - pos2.x;
				spineDir.y = pos1.y - pos2.y;
				spineDir.z = 0;
				spineDir.normalize();
				axis = _bindSpineOrientation.cross(spineDir);
				var torsoRollRotation = new THREE.Quaternion();
				torsoRollRotation.setFromAxisAngle(axis, Math.acos(_bindSpineOrientation.dot(spineDir)));

				var temp = new THREE.Quaternion();
				temp.multiplyQuaternions(torsoPitchRotation, torsoRollRotation);

				_kinectSkeletonPose.jointPoses[mapIndex].orientation.multiplyQuaternions(torsoYawRotation, temp);
			}

			function updateSimpleJoint(sourceKinectJointIndex, targetKinectJointIndex) {
				var bindDir, currDir, axis;
				var mapIndex = _jointMapping[sourceKinectJointIndex];
				if (mapIndex < 0) return;

				var orientation;
				var sourceKinectJoint = _kinectUser.joints[sourceKinectJointIndex];
				var targetKinectJoint = _kinectUser.joints[targetKinectJointIndex];

				currDir = getPosition(targetKinectJoint).sub(getPosition(sourceKinectJoint));
				currDir.normalize();
				bindDir = _bindPoseOrientationsOfTrackedJoints[sourceKinectJointIndex];

				axis = bindDir.cross(currDir);
				axis.normalize();

				_globalWisdom[mapIndex] = true;
				orientation = _kinectSkeletonPose.jointPoses[mapIndex].orientation;
				orientation.setFromAxisAngle(axis, Math.acos(bindDir.dot(currDir)));
			}

			loader.load('assets/character.js', function (geometry) {
				var material;

				material = new THREE.MeshPhongMaterial( { color: 0xffffff, wireframe: true, opacity: 0.3, transparent: true, skinning: true, map: new THREE.Texture( generateTexture() ), normalMap: new THREE.Texture( generateTexture("#00ffff") ), specularMap: new THREE.Texture( generateTexture("#000000") ), bumpMap: new THREE.Texture( generateTexture("#000000") ) } );
				material.map.needsUpdate = true;
				material.normalMap.needsUpdate = true;
				material.specularMap.needsUpdate = true;
				material.bumpMap.needsUpdate = true;

				// create a characterMesh
				characterMesh = new THREE.SkinnedMesh(
					geometry,
					material
				);

				characterMesh.rotation.set(-Math.PI/2,0,-Math.PI/2);

				_skeleton = characterMesh.skeleton;

        mapJoints();
        initSkeleton();
        initBindPoseOrientations();

				characterLoaded = true;

				scene.add(characterMesh);
			});

			window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize(){

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {
				renderer.render( scene, camera );
				controls.update();
				requestAnimationFrame(render);
			}

			onWindowResize();
			render();

			if(kinect.open()) {
				kinect.on('bodyFrame', function(bodyFrame){
					if(!characterLoaded) {
						return;
					}
					var body = false;
					for (var i = bodyFrame.bodies.length - 1; i >= 0; i--) {
						if(bodyFrame.bodies[i].tracked) {
							body = bodyFrame.bodies[i];
							break;
						}
					}
					if(!body) {
						return;
					}
					_kinectUser = body;
					updatePose();
				});

				kinect.openBodyReader();
			}
		})();
		</script>
	</body>
</html>
